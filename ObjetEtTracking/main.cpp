#include "cameraPos.h"
#include "objloader.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <iostream>

#include <opencv/cv.h>
#include <fstream>
using namespace cv;

//Aruco
#include "aruco\aruco.h"

using namespace aruco;


#ifdef __WIN32__
#include <windows.h>
#endif

#include "GL\glut.h" 

//Position de la voiture pour son déplacement dans la ville
float xpos = 0, ypos = 0, zpos = 0, xrot = 0, yrot = 0, angle=0.0;

float cRadius = 10.0f; // L'angle en degré de notre caractère (utile ?)

float lastx, lasty;

object_type *objarray[2];  //Contient notre objet à charger 

//Paramètres de lumière
GLfloat light_ambient[]= { 0.1f, 0.1f, 0.1f, 0.1f };
GLfloat light_diffuse[]= { 1.0f, 1.0f, 1.0f, 0.0f };
GLfloat light_specular[]= { 1.0f, 1.0f, 1.0f, 0.0f };
GLfloat light_position[]= { 100.0f, 0.0f, -10.0f, 1.0f };

//Paramètres des matériaux
GLfloat mat_ambient[]= { 0.5f, 0.5f, 0.0f, 0.0f };
GLfloat mat_diffuse[]= { 0.5f, 0.5f, 0.0f, 0.0f };
GLfloat mat_specular[]= { 1.0f, 1.0f, 1.0f, 0.0f };
GLfloat mat_shininess[]= { 1.0f };

int screen_width=800,screen_height=600;

//Pour la détection des marqueurs => Camera Position par Aruco
string TheInputVideo,TheIntrinsicFile,TheBoardConfigFile;
float TheMarkerSize=-1;
VideoCapture TheVideoCapturer;
Mat TheInputImage,TheUndInputImage,TheResizedImage;
CameraParameters TheCameraParams;
Size TheGlWindowSize=Size(screen_width,screen_height);
bool TheCaptureFlag=true; 
MarkerDetector MDetector;
vector<Marker> TheMarkers;
//la planche
BoardDetector TheBoardDetector;
BoardConfiguration TheBoardConfig;
pair<Board,float> TheBoardDetected; //la planche et ses probas

//test clavier pour taille Objet
float facteurZoom = 0.125f; //valeur pour tuture.obj

/** Initialisation d'OpenGl (vue, etc.)
*
*/

void init(string obj)
{
     glClearColor(0.0, 0.0, 0.0, 0.0); // Met le fond en noir si aucune vidéo n'est chargé (cas limite)
	
    // Initialisation du viewport (fênetre d'affichage)
    glViewport(0,0,screen_width,screen_height);  

    // Passage en mode Projection 
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity(); // Initialisation de la matrice de projection à l'identité
    gluPerspective(45.0f,(GLfloat)screen_width/(GLfloat)screen_height,0.5f,100000000.0f);     


	//Initialisation et activation des lumières (utile ?)
    glLightfv (GL_LIGHT1, GL_AMBIENT, light_ambient);
    glLightfv (GL_LIGHT1, GL_DIFFUSE, light_diffuse);
    glLightfv (GL_LIGHT1, GL_DIFFUSE, light_specular);
    glLightfv (GL_LIGHT1, GL_POSITION, light_position);    
    glEnable (GL_LIGHT1);
    glEnable (GL_LIGHTING);

    //Initialisation et activitation des matériaux (utile ?)
	glMaterialfv (GL_FRONT, GL_AMBIENT, mat_ambient);
    glMaterialfv (GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv (GL_FRONT, GL_DIFFUSE, mat_specular);
    glMaterialfv (GL_FRONT, GL_POSITION, mat_shininess);    

	//Initialisations diverses d'OpenGl
    glShadeModel(GL_SMOOTH); // Type des Shaders utilisés
	glHint (GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // Correction de la perspective du texture mapping
    glEnable(GL_TEXTURE_2D); // Activation des textures
    glPolygonMode (GL_FRONT_AND_BACK, GL_FILL); // Les polygones sont "remplies"
	glEnable(GL_CULL_FACE); // Activation du back face culling
   

	for (int i=0;i<1;i++)
	{
	printf("*************\n");
		objarray[i] = new (object_type);
		objarray[i]->objloader(obj);
		objarray[i]->objdatadisplay();      
	}

}


/** Fonction appelée dès qu'un redimensionnement de la taille de la fenêtre est effectué.
 *
 * @param p_width : largeur (pixels) de la vue (fenêtre)
 * @param p_height : hauteur (pixels) de la vue (fenêtre)
 */

void resize (int p_width, int p_height)
{
	if (screen_width==0 && screen_height==0) exit(0);

	screen_width=p_width; // On obtient la nouvelle taille de la fenêtre : ici largeur
	screen_height=p_height; // et là, hauteur

	glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // O supprime les buffers de couleurs et de profondeurs pour la nouvelle image
	glViewport(0,0,screen_width,screen_height); // Transformation de la fenêtre

	glMatrixMode(GL_PROJECTION); // Transformation de la matrice
	glLoadIdentity(); // On réinitialise la matrice de projection à l'identité
	gluPerspective(45.0f,(GLfloat)screen_width/(GLfloat)screen_height,1.0f,100000000.0f);

	glutPostRedisplay (); // On re-rend la scène
	TheGlWindowSize=Size(screen_width,screen_height); //on sauvegarde la taille de la fenêtre pour la suite
}

/** Gestion du clavier.
 * Prise en charge de la taille de l'objet (+/- et réinit à 0)
 * et déplacements caméra/objet (pour débug principalement)
 */


void keyboard (unsigned char key, int x, int y) {
    if (key=='q')
    {
		xrot += 1;
		if (xrot >360) xrot -= 360;
    }

	if (key=='+')
		facteurZoom=facteurZoom*2;
	if (key=='-')
		facteurZoom=facteurZoom/2;
	if (key=='0')
		facteurZoom=1;
    if (key=='z')
		xrot -= 1;

if (xrot < -360) 
	xrot += 360;
    

    if (key=='w')
    {
		float xrotrad, yrotrad;
		yrotrad = (yrot / 180 * 3.141592654f);
		xrotrad = (xrot / 180 * 3.141592654f); 
		xpos += float(sin(yrotrad));
		zpos -= float(cos(yrotrad));
		ypos -= float(sin(xrotrad));
    }

    if (key=='s')
    {
		float xrotrad, yrotrad;
		yrotrad = (yrot / 180 * 3.141592654f);
		xrotrad = (xrot / 180 * 3.141592654f); 
		xpos -= float(sin(yrotrad));
		zpos += float(cos(yrotrad));
		ypos += float(sin(xrotrad));
    }

    if (key=='d')
    {
		float yrotrad;
		yrotrad = (yrot / 180 * 3.141592654f);
		xpos += float(cos(yrotrad)) * 0.2;
		zpos += float(sin(yrotrad)) * 0.2;
    }

    if (key=='a')
    {
		float yrotrad;
		yrotrad = (yrot / 180 * 3.141592654f);
		xpos -= float(cos(yrotrad)) * 0.2;
		zpos -= float(sin(yrotrad)) * 0.2;
    }

    if (key==27)
    {
		exit(0);
    }
}

/** Support de la souris.
 * Mouvement et clic. Pas utilisé pour le moment
*/

void mouseMovement(int x, int y) {
	int diffx=x-lastx; //check the difference between the current x and the last x position
	int diffy=y-lasty; //check the difference between the current y and the last y position
	lastx=x; //set lastx to the current x position
	lasty=y; //set lasty to the current y position
	xrot += (float) diffy; //set the xrot to xrot with the addition of the difference in the y position
	yrot += (float) diffx;    //set the xrot to yrot with the addition of the difference in the x position
}


/** Génère l'image en cours 
 * SUBROUTINE display(void)
 *
 * This is our main rendering subroutine, called each frame
 * 
 *********************************************************/

void display(void)
{
    if (TheResizedImage.rows==0) //On attend que l'image soit bien réinitialisée avant de continuer
        return;
    ///C'est bon, image réinitialisée
    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
    ///On rend l'image dans le buffer
    glMatrixMode(GL_MODELVIEW); //Positionnement de la caméra
    glLoadIdentity();

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
	glOrtho(0, TheGlWindowSize.width, 0, TheGlWindowSize.height, -1.0, 5.0);
    glViewport(0, 0, TheGlWindowSize.width , TheGlWindowSize.height);
    glDisable(GL_TEXTURE_2D);
    glPixelZoom( 1, -1);
    glRasterPos3f( 0, TheGlWindowSize.height  - 0.5, -1.0f );
    glDrawPixels ( TheGlWindowSize.width , TheGlWindowSize.height , GL_RGB , GL_UNSIGNED_BYTE , TheResizedImage.ptr(0) ); //rend la vidéo
	

    ///On récupère la matrice de projection afin de faire nos rendus dans l'environnement comme si on filmait depuis la caméra
    glMatrixMode(GL_PROJECTION);
    double proj_matrix[16];

    TheCameraParams.glGetProjectionMatrix(TheInputImage.size(),TheGlWindowSize,proj_matrix,0.05,facteurZoom*10);
    glLoadIdentity();
    glLoadMatrixd(proj_matrix);
    glLineWidth(2);
    //Pour chaque marqueur (démo plus)
    double modelview_matrix[16];

    /*    for (unsigned int m=0;m<TheMarkers.size();m++)
        {
            TheMarkers[m].glGetModelViewMatrix(modelview_matrix);
            glMatrixMode(GL_MODELVIEW);
            glLoadIdentity();
            glLoadMatrixd(modelview_matrix);
    // 		axis(TheMarkerSize);
            glColor3f(1,0.4,0.4);
            glTranslatef(0, TheMarkerSize/2,0);
            glPushMatrix();
            glutWireCube( TheMarkerSize );

            glPopMatrix();
        }*/
    //Si la planche est détecté avec assez de probabilités, on affiche l'objet
    if (TheBoardDetected.second>0.3) {
        TheBoardDetected.first.glGetModelViewMatrix(modelview_matrix);
        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();
        glLoadMatrixd(modelview_matrix);
        glColor3f(0,1,0);
        glTranslatef(0, TheMarkerSize/2,0); //On est pile sur le plan des markers
        glPushMatrix();
		
		glEnable(GL_DEPTH_TEST); // Cache les éléments normalement cachés : c'est le Z-Buffer

		if (objarray[0]->id_texture!=-1) 
		{
			glBindTexture(GL_TEXTURE_2D, objarray[0]->id_texture); // On active les textures
			glEnable(GL_TEXTURE_2D); // Texture mapping ok
			//printf("Textures chargées");
		}
		else
			glDisable(GL_TEXTURE_2D); // Texture mapping OFF
		
		/**
		Permet de faire grossir/minimiser les éléments affichés à l'écran (+ pour zoomer, - pour dézoomer, 1 pour revenir à la taille d'origine)
		**/
		glScalef(facteurZoom, facteurZoom, facteurZoom);

		objarray[0]->render();

        //glutWireTeapot( TheMarkerSize );

		glDisable(GL_DEPTH_TEST); // Cache les éléments normalement cachés : c'est le Z-Buffer
        glPopMatrix();

    }

    glutSwapBuffers();


}

/** vIdle, détecte les marqueurs entre chaque itération **/

void vIdle()
{
    if (TheCaptureFlag) {
        //capture image
        TheVideoCapturer.grab();
        TheVideoCapturer.retrieve( TheInputImage);
        TheUndInputImage.create(TheInputImage.size(),CV_8UC3);
        //by deafult, opencv works in BGR, so we must convert to RGB because OpenGL in windows preffer
        cv::cvtColor(TheInputImage,TheInputImage,CV_BGR2RGB);
        //remove distorion in image
        cv::undistort(TheInputImage,TheUndInputImage, TheCameraParams.CameraMatrix,TheCameraParams.Distorsion);
        //detect markers
        MDetector.detect(TheUndInputImage,TheMarkers,TheCameraParams.CameraMatrix,Mat(),TheMarkerSize);
        //Detection of the board
        TheBoardDetected.second=TheBoardDetector.detect( TheMarkers, TheBoardConfig,TheBoardDetected.first, TheCameraParams,TheMarkerSize);
        //chekc the speed by calculating the mean speed of all iterations
        //resize the image to the size of the GL window
        cv::resize(TheUndInputImage,TheResizedImage,TheGlWindowSize);
    }
    glutPostRedisplay();
}

/** La fonction main.
* @param argv : listing des paramètres nécessaire : l'obj à charger, la vidéo ou live, la configuration de la planche, les données de corrections de déformations de la caméra et la taille des marqueurs (en m)
*
*/


int main(int argc, char **argv)
{
	/** Pour débugger plus vite !
	if (a/rgc!=6) {
        cerr<<"Nombre d'arguments invalide"<<endl;
        cerr<<"Ordre demandé : objet (triagulaire) .obj (in.avi|live) boardConfig.yml  intrinsicsLogitech.yml   size "<<endl;
        return false;
    }**/
	
	// Lignes suivantes remplacées par le "command arguments" suivant : "$(RELEASE_DIR)/roue de charrue.obj" "$(RELEASE_DIR)/video.avi" "$(RELEASE_DIR)/board_meters.yml" "$(RELEASE_DIR)/intrinsicsLogitech.yml" "0.039"

	/*argv[1] = "voiture.obj";
	argv[2] = "video.avi";
	argv[3] = "board_meters.yml";
	argv[4] = "intrinsics.yml";
	argv[5] = "0.039";*/
	

	// .obj à récupérer
	std::string obj = argv[1];

	/** Dépendance à Aruco et OpenCv **/

	//vidéo
	TheInputVideo=argv[2];

	//Fichier config du board
    TheBoardConfigFile=argv[3];

	//Caméra calibration info
    TheIntrinsicFile=argv[4];

	//taille des marqueurs
    TheMarkerSize=atof(argv[5]);

	//Lecture des infos du board
        TheBoardConfig.readFromFile(TheBoardConfigFile);

        //CHarge la vidéo donnée en paramètre
        if (TheInputVideo=="live")  //Lecture depuis la première webcam sur l'ordinateur
            TheVideoCapturer.open(0);
        else TheVideoCapturer.open(TheInputVideo);
        if (!TheVideoCapturer.isOpened())
        {
            cerr<<"Impossible de lire la vidéo"<<endl;
            return -1;

        }

        //Lecture de la première image
        TheVideoCapturer>>TheInputImage;
        //Lit les paramètres de la caméra (passés en argument)
        TheCameraParams.readFromXMLFile(TheIntrinsicFile);
        TheCameraParams.resize( TheInputImage.size());

	/** fin dépendance aruco/openCv **/

    // On utilise GLUT pour charger la fenêtre, gérer les entrées (clavier/souris) et interraction avec la fenêtre
    glutInit(&argc, argv);    
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
	screen_width = TheInputImage.size().width;
	screen_height = TheInputImage.size().height;
	glutInitWindowSize(TheInputImage.size().width,TheInputImage.size().height);    
	glutInitWindowPosition(0,0);
    glutCreateWindow("Echap pour quitter");    
    glutDisplayFunc(display);
    glutIdleFunc(vIdle);
    glutReshapeFunc (resize);

	// Prise en charge du clavier et souris 
	//glutPassiveMotionFunc(mouseMovement); 
	glutKeyboardFunc (keyboard); 

	//initialisation de l'obj
	init(obj);
    glutMainLoop();

    return(0);    
}